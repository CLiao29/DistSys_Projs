package mapreduce

import (
	"log"
	"strconv"
	"strings"
	"unicode"
)

// our simplified version of MapReduce does not supply a key to the
// Map function, as in Google's MapReduce paper; only a value,
// which is a portion of the input file's content
func WCMap(value string) []KeyValue {
	// key: document name
	// value: document contents for each word w in value:
	// EmitIntermediate(w, "1");

	intermediate := make([]KeyValue, 0)

	runes := []rune(value)
	for i := 0; i < len(runes); i++ {
		if !unicode.IsLetter(runes[i]) && runes[i] != ' ' {
			runes[i] = ' '
		}
	}
	editedVal := string(runes)

	words := strings.Fields(editedVal)

	for _, w := range words {

		intermediate = append(intermediate, KeyValue{Key: w, Value: "1"})
	}
	return intermediate
}

// called once for each key generated by Map, with a list of that
// key's values. should return a single output value for that key.
func WCReduce(key string, values []string) string {
	// key: a word
	// values: a list of counts
	// int result = 0;
	// for each v in values:
	//   result += ParseInt(v);
	// Emit(AsString(result));

	result := 0
	for _, v := range values {
		n, err := strconv.Atoi(v)
		if err != nil {
			log.Fatal(err)
		}

		result += n
	}

	return strconv.Itoa(result)
}
